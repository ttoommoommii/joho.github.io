<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">

  <!-- 3つのライブラリを読み込む -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <!-- 3つのライブラリを読み込む -->

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity WebGL Player | MwdiapipeWebGL</title>
  <link rel="shortcut icon" href="TemplateData/favicon.ico">
  <link rel="stylesheet" href="TemplateData/style.css">

  <!-- スタイルシートを読み込む -->
  <link rel="stylesheet" href="TemplateData/hands.css">
  <!-- スタイルシートを読み込む -->

</head>

<body>
  <div id="unity-container" class="unity-desktop">
    <canvas id="unity-canvas" width=960 height=600></canvas>
    <div id="unity-loading-bar">
      <div id="unity-logo"></div>
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
    </div>
    <div id="unity-warning"> </div>
    <div id="unity-footer">
      <div id="unity-webgl-logo"></div>
      <div id="unity-fullscreen-button"></div>
      <div id="unity-build-title">MwdiapipeWebGL</div>
    </div>
  </div>

  <!-- MediaPipeエリア-->
  <!-- Webカメラの映像（入力） -->
  <video class="input_video" style="display:none" id="input"></video>

  <div id="loading" , class="scaling-squares-spinner" :style="spinnerStyle">
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
    <div class="square"></div>
  </div>

  <!--  認識した手の形状を可視化した映像（出力）  -->
  <canvas class="output_canvas" id="output" width="320" height="180"></canvas>


  <!-- MediaPipe設定エリア-->
  <div class="mediapipe-setting">
    maxNumHands:<span id="maxNumHandsValue"></span><br>
    <input type="range" id="maxNumHandsOption" min="1" max="4" step="1" value="2"><br><br>
    minDetectionConfidence:<span id="minDetectionConfidenceValue"></span><br>
    <input type="range" id="minDetectionConfidenceOption" min="0" max="1" step="0.01" value="0.5"><br><br>
    minTrackingConfidence:<span id="minTrackingConfidenceValue"></span><br>
    <input type="range" id="minTrackingConfidenceOption" min="0" max="1" step="0.01" value="0.5">
  </div>
  <!-- MediaPipeエリア-->


  <script>

    var container = document.querySelector("#unity-container");
    var canvas = document.querySelector("#unity-canvas");
    var loadingBar = document.querySelector("#unity-loading-bar");
    var progressBarFull = document.querySelector("#unity-progress-bar-full");
    var fullscreenButton = document.querySelector("#unity-fullscreen-button");
    var warningBanner = document.querySelector("#unity-warning");

    var n = 0

    // Shows a temporary message banner/ribbon for a few seconds, or
    // a permanent error message on top of the canvas if type=='error'.
    // If type=='warning', a yellow highlight color is used.
    // Modify or remove this function to customize the visually presented
    // way that non-critical warnings and error messages are presented to the
    // user.
    function unityShowBanner(msg, type) {
      function updateBannerVisibility() {
        warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
      }
      var div = document.createElement('div');
      div.innerHTML = msg;
      warningBanner.appendChild(div);
      if (type == 'error') div.style = 'background: red; padding: 10px;';
      else {
        if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
        setTimeout(function () {
          warningBanner.removeChild(div);
          updateBannerVisibility();
        }, 5000);
      }
      updateBannerVisibility();
    }

    var buildUrl = "Build";
    var loaderUrl = buildUrl + "/web.loader.js";
    var config = {
      dataUrl: buildUrl + "/web.data.unityweb",
      frameworkUrl: buildUrl + "/web.framework.js.unityweb",
      codeUrl: buildUrl + "/web.wasm.unityweb",
      streamingAssetsUrl: "StreamingAssets",
      companyName: "DefaultCompany",
      productName: "MwdiapipeWebGL",
      productVersion: "0.1.0",
      showBanner: unityShowBanner,
    };

    // By default, Unity keeps WebGL canvas render target size matched with
    // the DOM size of the canvas element (scaled by window.devicePixelRatio)
    // Set this to false if you want to decouple this synchronization from
    // happening inside the engine, and you would instead like to size up
    // the canvas DOM size and WebGL render target sizes yourself.
    // config.matchWebGLToCanvasSize = false;

    // If you would like all file writes inside Unity Application.persistentDataPath
    // directory to automatically persist so that the contents are remembered when
    // the user revisits the site the next time, uncomment the following line:
    // config.autoSyncPersistentDataPath = true;
    // This autosyncing is currently not the default behavior to avoid regressing
    // existing user projects that might rely on the earlier manual
    // JS_FileSystem_Sync() behavior, but in future Unity version, this will be
    // expected to change.

    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
      // Mobile device style: fill the whole browser client area with the game canvas:

      var meta = document.createElement('meta');
      meta.name = 'viewport';
      meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
      document.getElementsByTagName('head')[0].appendChild(meta);
      container.className = "unity-mobile";
      canvas.className = "unity-mobile";

      // To lower canvas resolution on mobile devices to gain some
      // performance, uncomment the following line:
      // config.devicePixelRatio = 1;

      unityShowBanner('WebGL builds are not supported on mobile devices.');
    } else {
      // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

      canvas.style.width = "800px";//Tom
      canvas.style.height = "450px";//Tom
    }

    loadingBar.style.display = "block";

    var script = document.createElement("script");
    script.src = loaderUrl;
    script.onload = () => {
      createUnityInstance(canvas, config, (progress) => {
        progressBarFull.style.width = 100 * progress + "%";
      }).then((unityInstance) => {
        loadingBar.style.display = "none";
        fullscreenButton.onclick = () => {
          unityInstance.SetFullscreen(1);
        };

        // MediaPipe Process Start//Tom
        _unityInstance = unityInstance;
        setTimeout(
          function () {
            mediapipeHandsStars();
          },
          "3000"
        );//Tom

      }).catch((message) => {
        alert(message);
      });
    };
    document.body.appendChild(script);

    // Unity StartUp Process End///////////////////////////////////////////////////

    // MediaPipe Hands Process Start///////////////////////////////////////////////
    // MediaPipe Hands Instance
    let hands = null;
    hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });


    function mediapipeHandsStars() {


      const video = document.getElementById('input');
      const canvas = document.getElementById('output');
      const ctx = canvas.getContext('2d');

      //関連ファイルの読み込み
      /*
      const config = {
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      };
      const hands = new Hands(config);
      */

      //カメラからの映像をhands.jsで使えるようにする
      const camera = new Camera(video, {
        onFrame: async () => {
          // Remove Loading Icon
          var loadingElement = document.getElementById("loading");
          if (loadingElement != null) {
            loadingElement.remove();
          }
          await hands.send({ image: video });
        },
        width: 320,
        height: 180
      });

      hands.setOptions({
        maxNumHands: 2,              //検出する手の最大数
        modelComplexity: 1,          //ランドマーク検出精度(0か1)
        minDetectionConfidence: 0.5, //手を検出するための信頼値(0.0~1.0)
        minTrackingConfidence: 0.5   //ランドマーク追跡の信頼度(0.0~1.0)
      });



      //形状認識した結果の取得
      hands.onResults(results => {
        // JS->Unity:ClearCanvas
        if (_unityInstance != null) {
          _unityInstance.SendMessage('Plane', 'ClearCanvas');
          _unityInstance.SendMessage('Plane1', 'ClearCanvas');

        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

        //console.log(results.multiHandLandmarks[0]);


        if (results.multiHandLandmarks) {
          results.multiHandLandmarks.forEach(marks => {
            // 緑色の線で骨組みを可視化
            drawConnectors(ctx, marks, HAND_CONNECTIONS, { color: '#0f0' });
            // 赤色でランドマークを可視化
            drawLandmarks(ctx, marks, { color: '#f00' });

            if (results.multiHandLandmarks.length == 1 && results.multiHandedness[0].label=="Left") {
              n=0;
              console.log(results.multiHandedness[0].label+ " "+results.multiHandedness[0].index+ " " + n);
            }
            else if (results.multiHandLandmarks.length == 1 && results.multiHandedness[0].label=="Right") {
              n=1;
              console.log(results.multiHandedness[0].label+ " "+results.multiHandedness[0].index+ " " + n);
            }
            //if (results.multiHandLandmarks.length == 2) {
              //n=1;
            //  console.log(results.multiHandedness[0].label+  " "+results.multiHandedness[0].index + " "+ results.multiHandedness[1].label + " "+results.multiHandedness[0].index+ " " + n);
            //}
            

            

            // JS->Unity:DrawHandsLandmark
            if (_unityInstance != null) {
              if (n == 0) {
                //console.log(results.multiHandedness[0].label + " " + n);
                _unityInstance.SendMessage('Plane', 'DrawHandsLandmark', String(JSON.stringify(marks)));
                n = 1;
              } else if (n == 1)  {
                //console.log(results.multiHandedness[0].label);
                _unityInstance.SendMessage('Plane1', 'DrawHandsLandmark', String(JSON.stringify(marks)));
                n = 0;
              }
              //_unityInstance.SendMessage('Plane', 'T', String(JSON.stringify(marks)));
            }//if

          });//forEach
        }//if(results.multiHandLandmarks)
      });//onResults

      camera.start();

    }//形状認識した結果の取得

    // MediaPipe Hands Process End/////////////////////////////////////////////////

    // MediaPipe Setting Callback Start////////////////////////////////////////////
    const maxNumHandsOptionElement = document.getElementById('maxNumHandsOption');
    const maxNumHandsValueElement = document.getElementById('maxNumHandsValue');
    const setMaxNumHandsValue = (val) => {
      maxNumHandsValueElement.innerText = val;

      if (hands != null) {
        hands.setOptions({
          maxNumHands: parseFloat(val)
        });
      }
    }
    const maxNumHandsValueChange = (e) => {
      setMaxNumHandsValue(e.target.value);
    }

    const minDetectionConfidenceOptionElement = document.getElementById('minDetectionConfidenceOption');
    const minDetectionConfidenceValueElement = document.getElementById('minDetectionConfidenceValue');
    const setMinDetectionConfidenceValue = (val) => {
      minDetectionConfidenceValueElement.innerText = val;

      if (hands != null) {
        hands.setOptions({
          minDetectionConfidence: parseFloat(val)
        });
      }
    }
    const maxMinDetectionConfidenceChange = (e) => {
      setMinDetectionConfidenceValue(e.target.value);
    }

    const minTrackingConfidenceOptionElement = document.getElementById('minTrackingConfidenceOption');
    const minTrackingConfidenceValueElement = document.getElementById('minTrackingConfidenceValue');
    const setMinTrackingConfidenceValue = (val) => {
      minTrackingConfidenceValueElement.innerText = val;

      if (hands != null) {
        hands.setOptions({
          minTrackingConfidence: parseFloat(val)
        });
      }
    }
    const maxMinTrackingConfidenceChange = (e) => {
      setMinTrackingConfidenceValue(e.target.value);
    }



    window.onload = () => {

      maxNumHandsOptionElement.addEventListener('input', maxNumHandsValueChange);
      setMaxNumHandsValue(maxNumHandsOptionElement.value);

      minDetectionConfidenceOptionElement.addEventListener('input', maxMinDetectionConfidenceChange);
      setMinDetectionConfidenceValue(minDetectionConfidenceOptionElement.value);

      minTrackingConfidenceOptionElement.addEventListener('input', maxMinTrackingConfidenceChange);
      setMinTrackingConfidenceValue(minTrackingConfidenceOptionElement.value);

    }

    // MediaPipe Setting Callback End/


    //tom
    let _unityInstance = null;//Tom



  </script>
</body>

</html>
